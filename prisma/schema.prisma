generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

/// This model contains row level security and requires additional setup for migrations. Visit https://pris.ly/d/row-level-security for more info.
/// TODO: Should be renamed to "User" not users
model User {
  id                   String       @id @default(uuid())
  address              String       @unique
  created_at           DateTime?    @default(now()) @db.Timestamptz(6)
  last_logged_in       DateTime?    @default(now()) @db.Timestamptz(6)
  username             String?      @unique
  badges               Json[]       @db.Json
  level                BigInt?      @default(0)
  quests               Json[]       @db.Json
  friendships          Friendship[] @relation("user")
  friendships_accepted Friendship[] @relation("friend")
  inventory            Json[]       @db.Json
  rewards_earned       Reward[]
  nonce                String?
  profile_picture      String?
  nfts                 NFT[]
  created_raffles      Raffle[]
  user_raffles         UserRaffle[]
  role                 UserRole     @default(USER)
  offers_made          Offer[]      @relation("offerFrom")
  offers_received      Offer[]      @relation("offerTo")
  created_listings     Listing[]
  purchases            Purchase[]
}

//Friend request made through client-side
model Friendship {
  id         String   @id @default(uuid())
  created_at DateTime @default(now())
  user_id    String
  user       User     @relation("user", fields: [user_id], references: [id])
  friend_id  String
  friend     User     @relation("friend", fields: [friend_id], references: [id])
}

//this is used to connect the User and raffles table in a many-to-many relationship
model UserRaffle {
  id        String @id @default(uuid())
  user_id   String
  user      User   @relation(fields: [user_id], references: [id])
  raffle_id String
  raffle    Raffle @relation(fields: [raffle_id], references: [id])
}

enum UserRole {
  ADMIN
  USER
}

model Purchase {
  id           String   @id @default(uuid())
  listing      Listing  @relation(fields: [listing_id], references: [id])
  listing_id   String
  buyer        User     @relation(fields: [buyer_id], references: [id])
  buyer_id     String
  amount       Float
  purchased_at DateTime @default(now())
}

model Listing {
  id         String     @id @default(uuid())
  nft        NFT        @relation(fields: [nft_id], references: [id])
  nft_id     String
  price      Float
  currency   String
  creator    User       @relation(fields: [creator_id], references: [id])
  creator_id String
  created_at DateTime   @default(now())
  updated_at DateTime   @updatedAt
  purchase   Purchase[]
}

enum EnumOfferStatus {
  PENDING
  ACCEPTED
  DECLINED
  EXPIRED
}

model Offer {
  id        String          @id @default(uuid())
  from      User            @relation(name: "offerFrom", fields: [from_id], references: [id])
  from_id   String
  to        User            @relation(name: "offerTo", fields: [to_id], references: [id])
  to_id     String
  nft       NFT             @relation(fields: [nft_id], references: [id])
  nft_id    String
  amount    Float
  message   String?
  status    EnumOfferStatus
  createdAt DateTime        @default(now())
  updatedAt DateTime        @updatedAt
}

/// This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
/// This model contains row level security and requires additional setup for migrations. Visit https://pris.ly/d/row-level-security for more info.
model Raffle {
  id               String       @id @default(uuid())
  created_at       DateTime?    @default(now()) @db.Timestamptz(6)
  name             String?
  token_id         Int?
  nft_address      String?      @db.VarChar
  start_date       DateTime?    @db.Timestamptz(6)
  end_date         DateTime?    @db.Timestamptz(6)
  raffle_cost      Float?       @db.Real
  max_tickets      Int?
  sold_tickets     Int?
  created_by       String?      @db.VarChar
  participant_list UserRaffle[]
  transaction_list Json[]       @db.Json
  favourite_count  Int?
  nft_image        String?      @db.VarChar
  raffler          User?        @relation(fields: [raffler_id], references: [id])
  raffler_id       String?
}

model NFT {
  id                  String      @id @default(uuid())
  token_id            String      @unique
  name                String
  description         String
  image               String
  collection_contract Collection? @relation(fields: [collection_id], references: [id])
  collection_id       BigInt?
  owner               User?       @relation(fields: [owner_id], references: [id])
  owner_id            String?
  created_at          DateTime    @default(now())
  updated_at          DateTime    @updatedAt
  listed_at           DateTime?
  category            Category?   @relation(fields: [category_id], references: [id])
  category_id         String?
  offers              Offer[]
  listings            Listing[]
}

model Category {
  id         String   @id @default(uuid())
  name       String   @unique
  created_at DateTime @default(now())
  updated_at DateTime @updatedAt
  nfts       NFT[]
}

model Reward {
  id        BigInt  @id @default(autoincrement())
  dispensed BigInt  @default(0)
  User      User?   @relation(fields: [userId], references: [id])
  userId    String?
}

/// Model to store NFT collection data
model Collection {
  id                         BigInt    @id @default(autoincrement())
  contract_address           String    @unique
  name                       String
  symbol                     String
  description                String?
  website                    String?
  email                      String?
  twitter                    String?
  discord                    String?
  telegram                   String?
  github                     String?
  instagram                  String?
  medium                     String?
  logo_url                   String?
  banner_url                 String?
  featured_url               String?
  large_image_url            String?
  attributes                 Json?
  erc_type                   String
  token_type                 String
  deploy_block_number        BigInt
  owner                      String
  contract_deployer          String
  verified                   Boolean
  opensea_verified           Boolean
  baddogs_verified           Boolean
  rug_verified               Boolean
  sus_verified               Boolean
  royalty                    Float?
  items_total                BigInt
  amounts_total              BigInt
  owners_total               Int
  opensea_floor_price        Float?
  floor_price                Float
  collections_with_same_name Json?
  price_symbol               String
  volume_total               Float?
  sales_total                Int?
  average_price              Float?
  lowest_price_24h           Float?
  average_price_24h          Float?
  volume_24h                 Float?
  sales_24h                  Int?
  highest_price              Float?
  volume_1d                  Float?
  volume_7d                  Float?
  volume_30d                 Float?
  volume_change_1d           String?
  volume_change_7d           String?
  volume_change_30d          String?
  market_cap                 BigInt?
  average_price_change_1d    String?
  average_price_change_7d    String?
  average_price_change_30d   String?
  last_ingested_at           DateTime?
  last_updated_at            DateTime?
  created_at                 DateTime?
  asset_contract_type        String?
  blur_floor_price           Float?
  chain_identifier           String?
  contract_name              String?
  image_url                  String?
  is_featured                Boolean?
  is_hidden                  Boolean?
  is_nsfw                    Boolean?
  looksrare_floor_price      Float?
  slug                       String?
  version                    Float?
  NFT                        NFT[]
}
